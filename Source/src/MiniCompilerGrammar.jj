PARSER_BEGIN(CSharpMiniCompiler)import Nodes.*;import java.io.File;import java.io.FileInputStream;
public class CSharpMiniCompiler{  public static void main(String args []) throws ParseException  {    try    {      // Initialize a new instance of our mini C# compiler and give it a stream to a file containing C# code      CSharpMiniCompiler compiler = new CSharpMiniCompiler(new FileInputStream(new File("src/sampleCSharp.txt")));      // Start the compiler      TreeNode main = compiler.start();      // Execute the main root node containing all children nodes      main.Execute();    }    catch (Exception e)    {      // Print the message if an exception is thrown      System.out.println(e.getMessage());    }  }}PARSER_END(CSharpMiniCompiler)SKIP :{  " "| "\r"| "\t"| "\n"}TOKEN:{  < PLUS: "+">| < MINUS: "-" >| < DIVIDE: "/" >| < MULTIPLY: "*" >| < EQ: "==" >| < ASSIGN: "=" >| < PLUSEQ: "+=" >| < MINUSEQ: "-=" >| < MULEQ: "*=" >| < DIVEQ: "/=" >| < LT: "<" >| < GT: ">" >| < LE: "<=" >| < GE: ">=" >| < NEQ: "!=" >| < BOOL_AND: "&&" >| < BOOL_OR: "||" >| < LPAREN: "(" >| < RPAREN: ")" >| < LCURLY: "{" >| < RCURLY: "}" >| < LBRACKET: "[" >| < RBRACKET: "]" >| < NAMESPACE: "namespace" >| < PUBLIC: "public" >| < STATIC: "static" >| < VOID: "void" >| < MAIN: "Main" >| < CLASS: "class" >| < COMMA: "," >| < IF: "if" >| < ELSE: "else" >| < INC: "++" >| < DEC: "--" >| < DO: "do" >| < WHILE: "while" >| < SWITCH: "switch" >| < CASE: "case" >| < DEF: "default" >| < BREAK: "break" >| < FALSE: "false" >| < TRUE: "true" >| < COLON: ":" >| < FOR: "for" >| < SEMICOLON: ";">| < DOT: "." >| < INT_DT: "int" >| < DOUBLE_DT: "double" >| < STRING_DT: "string" >| < BOOL_DT: "bool" >| < PRINT: "Console.WriteLine" >}TOKEN:{  < #DIGIT: ["0"-"9"] >| < #LETTER: (["a"-"z"] | ["A"-"Z"]) >| < INT: (["1"-"9"](<DIGIT>)+ | ["0"-"9"]) >| < DOUBLE: <INT><DOT><INT> >| < VAR_NAME: ("_" | <LETTER>)("_" | <LETTER> | <DIGIT>)* >| < STRING: "\"" (~["\""])* "\"" >}// Main entry point of the compilerTreeNode start() throws Exception:{ TreeNode main; }{  <NAMESPACE> <VAR_NAME> <LCURLY>	  	<PUBLIC> <CLASS> <VAR_NAME> <LCURLY>	  		<PUBLIC> <STATIC> <VOID> <MAIN> <LPAREN> <STRING_DT> <LBRACKET> <RBRACKET> <VAR_NAME> <RPAREN> <LCURLY>	   			main = blockOfCode() { return main; }	   		<RCURLY>	 	<RCURLY>     <RCURLY>}// Reads an if statement with all its specifications and returns an IfNodeIfNode ifStatement() throws Exception:{  // Main if node  IfNode ifNode = new IfNode();  // Boolean expression to be evaluated   BooleanExpressionNode expression;  // Block of code for the if node  BlockNode ifBlock;  // Block of code for the else block (optional)  BlockNode elseBlock;  // Single statement for the if node  TreeNode singleIfStatement;  // Single statement for the else node  TreeNode singleElseStatement;}{  <IF> <LPAREN> expression = booleanExpressionStatement() { ifNode.Add(expression); } <RPAREN>
     (
         singleIfStatement = statement() { ifNode.Add(singleIfStatement); } | <LCURLY> ifBlock = blockOfCode() { ifNode.Add(ifBlock); } <RCURLY>
     )   
     (
       LOOKAHEAD(2)
  <ELSE>
       (
          singleElseStatement = statement() { ifNode.Add(singleElseStatement); } | <LCURLY> elseBlock = blockOfCode() { ifNode.Add(elseBlock); } <RCURLY>
       )  
     )?
  {    return ifNode;  }}// Reads a boolean expressions and returns a BooleanExpresssionNode describing the expression flowBooleanExpressionNode booleanExpressionStatement() throws Exception:{  // Expression to be returned  BooleanExpressionNode expression = new BooleanExpressionNode();  // Current condition to be added to the expression  ConditionNode condition;  // Boolean operator to be presented between conditions (&&, ||)  BooleanOperatorNode booleanOperatorNode;}{  condition = conditionStatement() { expression.Add(condition); }  (    booleanOperatorNode = captureBooleanOperator() { expression.Add(booleanOperatorNode); }    condition = conditionStatement() { expression.Add(condition); }  )*  {    return expression;  }}// Reads a condition and returns a ConditionNode describing the condition contentConditionNode conditionStatement() throws Exception:{  // Condition node to be returned  ConditionNode conditionNode = new ConditionNode();  // Operand variables of the condition  VarNameNode var1, var2;  // Comparision operator between operands  ComparisionOperationNode opNode;  // Literal values as operands   LiteralValueNode literal1, literal2;  // Boolean variable incase the condition was read as 'true' or 'false'  Boolean bool;}{  (    ( LOOKAHEAD(2)      (var1 = captureVarName() { conditionNode.Add(var1); } | literal1 = captureLiteralValue() { conditionNode.Add(literal1); } ) 	    (	      opNode = comparisionOperation() { conditionNode.Add(opNode); }	      (var2 = captureVarName() { conditionNode.Add(var2); } | literal2 = captureLiteralValue() { conditionNode.Add(literal2); })	    )?	| ( bool = captureBoolean() { conditionNode.Add(new LiteralValueNode(bool)); } )	  )  )  {    return conditionNode;  }}// Reads a while statement and returns a while node describing the contents of the statementWhileNode whileStatement() throws Exception:{  // While node to be returned  WhileNode whileNode = new WhileNode();  // Boolean expression to be evaluated for the execution of the while code block  BooleanExpressionNode expression;  // Block of code for the while statement  BlockNode block;  // Single statement in case it was as so  TreeNode singleStatement;}{  <WHILE> <LPAREN> expression = booleanExpressionStatement() { whileNode.Add(expression); } <RPAREN>  (    singleStatement = statement() { whileNode.Add(singleStatement); } | <LCURLY> block = blockOfCode() { whileNode.Add(block); } <RCURLY>  )  {    return whileNode;  }}// Reads a do while statement and returns DoWhileNode describing its contentDoWhileNode doWhileStatement() throws Exception:{  // DoWhileNode to be returned  DoWhileNode doWhileNode = new DoWhileNode();  // Expression to be evaluated for the execution of the do while statement  BooleanExpressionNode expression;  // Block of code to be executed when the expression is evaluated to true  BlockNode block;  // Single statement in case is was as so  TreeNode singleStatement;}{  <DO> ( (singleStatement = statement() { doWhileNode.Add(singleStatement); }) | (<LCURLY> block = blockOfCode() { doWhileNode.Add(block); } <RCURLY>) )   <WHILE> <LPAREN> expression = booleanExpressionStatement() { doWhileNode.Add(expression); } <RPAREN>  {    return doWhileNode;  }}// Reads a switch statement and returned a SwitchNode describing its contentSwitchNode switchStatement() throws Exception:{  // Switch node to be returned  SwitchNode switchNode = new SwitchNode();  // Current case to be added to the switch node  BaseCase currentCase;  // Variable name to be tested in the switch statement  VarNameNode varName;}{  <SWITCH> <LPAREN> varName = captureVarName() { switchNode.Add(varName); } <RPAREN> <LCURLY>    ( currentCase = caseStatement() { switchNode.Add(currentCase); } )*    ( currentCase = defaultCaseStatement() { switchNode.Add(currentCase); } )?  <RCURLY>  {    return switchNode;  }}// Reads a normal case for the switch statmentCaseNode caseStatement() throws Exception:{  // Case node to be returned CaseNode caseNode; // Block of code to be executed for when the current case's value matches the tested value  BlockNode block; // Literal value belonging to the case and value to be tested and matched with the switch variable  LiteralValueNode literalValueNode;}{  <CASE> (literalValueNode = captureLiteralValue()) <COLON> block = blockOfCode()    {caseNode = new CaseNode(literalValueNode); caseNode.Add(block);  } <BREAK> <SEMICOLON>  {    return caseNode;  }}// Reads a default case for the switch statementDefaultCaseNode defaultCaseStatement() throws Exception:{  // Default case node to be returned  DefaultCaseNode defaultCaseNode = new DefaultCaseNode();  // Block of code to be executed if the execution reaches the default case  BlockNode block;}{  <DEF> <COLON> block = blockOfCode() { defaultCaseNode.Add(block); } <BREAK> <SEMICOLON>  {    return defaultCaseNode;  }}// Reads an assignment statement and returns an AssignNode describing its contentAssignNode assignStatement() throws Exception:{  // Assign Node to be returned  AssignNode assignNode = new AssignNode();  // Datatype to be read for the newly created variable  DataTypeNode typeNode;  // The newly created variable name  VarNameNode newVarNameNode;  // Literal value to be assigned for the newly created variable  LiteralValueNode literalValueNode;  // Other assignable values like (a variable, x++ expression)  TreeNode otherAssignableValueNode;}{  (      typeNode = dataType() { assignNode.Add(typeNode); } newVarNameNode = captureVarName() { assignNode.Add(newVarNameNode); } <ASSIGN>        (          literalValueNode = captureLiteralValue() { assignNode.Add(literalValueNode); }        | otherAssignableValueNode = otherAssignableValues() { assignNode.Add(otherAssignableValueNode); }        )  )    {    return assignNode;  }}// Reads a for statement and returned a ForNode describing its contentForNode forStatement() throws Exception:{  // ForNode to be returned  ForNode forNode = new ForNode();  // Initial assign node to be executed first  AssignNode initialAssign;  // Boolean expression to be evaluated when executing the code associated with the for statement  BooleanExpressionNode expression;  // The modification statement to be executed for every cycle is done in the for loop  ModificationNode modificationNode;  // Block of code to be executed when the expression is evaluated to true  BlockNode block;  // Single statement to be executed if it was so  TreeNode singleStatement;}{  <FOR> <LPAREN> initialAssign = assignStatement() { forNode.Add(initialAssign); } <SEMICOLON>  		expression = booleanExpressionStatement() { forNode.Add(expression); } <SEMICOLON>  		modificationNode = modificationStatement() { forNode.Add(modificationNode); } <RPAREN>  ( (singleStatement = statement() { forNode.Add(singleStatement); }) | (<LCURLY> block = blockOfCode() { forNode.Add(block); } <RCURLY>) )  { return forNode; }}// Reads an increment decrement statement and returned an IncDecNode describing its contentIncDecNode incrementDecrementStatement():{  // Node to be returned  IncDecNode incDecNode = new IncDecNode();  // Variable name to do the operation on  VarNameNode varNameNode;  // Operator to be used for the operation  IncDecOperatorNode incDecOperatorNode;}{  (    (varNameNode = captureVarName() { incDecNode.Add(varNameNode); } incDecOperatorNode = captureIncDecOperator() { incDecNode.Add(incDecOperatorNode); } )  | (incDecOperatorNode = captureIncDecOperator() { incDecNode.Add(incDecOperatorNode); } varNameNode = captureVarName() { incDecNode.Add(varNameNode); } )  )  {    return incDecNode;  }}// Reads a modification statement and returns a ModificationNode describing its contentModificationNode modificationStatement() throws Exception:{  // Node to be returned  ModificationNode modificationNode = new ModificationNode();  // Variabe to do the modification on  VarNameNode varNameNode;  // Modification operator to be used ('=', '+=', ....)  ModificationOperatorNode modificationOperatorNode;  // Literal value to be assigned to the variable  LiteralValueNode literalValueNode;  // Other assignable values like a variable or x++ expression  TreeNode otherAssignableValuesNode;  // Or could be a regular increment decrement statement  IncDecNode incDecNode;}{  (    LOOKAHEAD(2)    incDecNode = incrementDecrementStatement() { modificationNode.Add(incDecNode); }  | (      varNameNode = captureVarName() { modificationNode.Add(varNameNode); }	  modificationOperatorNode = captureModificationOperator() { modificationNode.Add(modificationOperatorNode); }	  (	    literalValueNode = captureLiteralValue() { modificationNode.Add(literalValueNode); }	  | otherAssignableValuesNode = otherAssignableValues() { modificationNode.Add(otherAssignableValuesNode); }	  )	)  )  {    return modificationNode;  }}// Reads a print statement and returned a print node decribing its contentPrintNode printStatement():{  // Node to be returned  PrintNode printNode = new PrintNode();  // Node to be printed (variable, literalValue)  TreeNode nodeToPrint;}{  <PRINT><LPAREN> (nodeToPrint = captureVarName() | nodeToPrint = captureLiteralValue() ) { printNode.Add(nodeToPrint); }  <RPAREN>  { return printNode; }}// Reads a block of code (multiple statements) and returns a block node describing its contentBlockNode blockOfCode() throws Exception:{  // Block node to be returned  BlockNode block = new BlockNode();  // Current node to be added to the block (statement)  TreeNode currentNode;}{	(	  currentNode = statement() { block.Add(currentNode); }	)*  {    return block;  }}// Reads a statement and returned a general base type for all statementTreeNode statement() throws Exception:{  // Node to be read and returned  TreeNode currentNode;}{  (      (currentNode = ifStatement())    | (currentNode = whileStatement())    | (currentNode = doWhileStatement())    | (currentNode = forStatement())    | (currentNode = switchStatement())    | (currentNode = assignStatement() <SEMICOLON>)    | (currentNode = printStatement() <SEMICOLON>)    | (currentNode = modificationStatement() <SEMICOLON>)  )  {    return currentNode;  }}// Assignable values like a variable or an expression like x+;TreeNode otherAssignableValues():{  // Variable name to be assigned  TreeNode copiedVarNameNode;  // Increment decrement statement   TreeNode incDecNode;}{  (  LOOKAHEAD(2)    incDecNode = incrementDecrementStatement() { return incDecNode; }  | copiedVarNameNode = captureVarName() { return copiedVarNameNode; }  )}// Captures a boolean operator and returned a BooleanOperatorNodeBooleanOperatorNode captureBooleanOperator():{ Token operator; }{  ( operator = <BOOL_AND> | operator = <BOOL_OR> ) { return new BooleanOperatorNode(operator.image); } }// Captures an increment decrement operator and returned an IncDecOperatorNodeIncDecOperatorNode captureIncDecOperator():{  Token operator;}{  ( operator = <INC> | operator = <DEC> ) { return new IncDecOperatorNode(operator.image); }}// Captures a variable name and returned a VarNameNodeVarNameNode captureVarName():{  Token varName;}{  varName = <VAR_NAME> { return new VarNameNode(varName.image); }}// Captures a datatype and returned a DataTypeNodeDataTypeNode dataType() throws Exception:{  Token type;}{  (type =  <INT_DT> | type =  <DOUBLE_DT> | type =  <STRING_DT> | type =  <BOOL_DT>) { return new DataTypeNode(type.image); }}// Captures a modification operator and returned a ModificationOperatorNodeModificationOperatorNode captureModificationOperator() throws Exception:{  Token operator;}{  (    operator = <PLUSEQ> | operator = <MINUSEQ> | operator = <MULEQ> | operator = <DIVEQ> | operator = <ASSIGN>  )  {    return new ModificationOperatorNode(operator.image);  }}// Captures a comparison operator and returned a ComparisionOperatorNodeComparisionOperationNode comparisionOperation():{  Token operation;}{  ( operation = <EQ> | operation = <GT> | operation = <LT> | operation = <GE> | operation = <LE> | operation = <NEQ>)  {    return new ComparisionOperationNode(operation.image);  }}// Captures a literal value (int, bool, string, double) and returned a LitaralValueNodeLiteralValueNode captureLiteralValue():{ Object value; }{  (value = captureInteger() | value = captureDouble() | value = captureString() | value = captureBoolean())  {    return new LiteralValueNode(value);  } }// Captures a string and returns itString captureString():{ Token string; } { string = <STRING> { return string.image.replace("\"", ""); } }// Captures a double and returns itDouble captureDouble():{ Token value; } { value = <DOUBLE> { return Double.parseDouble(value.image); } }// Captures an integer and returns itInteger captureInteger():{ Token value; } { value = <INT> { return Integer.parseInt(value.image); } }// Captures a boolean and returns itBoolean captureBoolean():{ Token value; } { (value = <TRUE> | value = <FALSE>) { return Boolean.parseBoolean(value.image); } }